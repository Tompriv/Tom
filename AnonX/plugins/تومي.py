import requests
import json
from AnonX import app
from pyrogram import Client
from pyrogram import filters
from pyrogram.types import Message
from pyrogram import Client, filters

import asyncio
import os

from AnonX import (Apple, Resso, SoundCloud, Spotify, Telegram, YouTube, app)
import requests
import pyrogram
from pyrogram import Client, emoji 
from config import *
from pyrogram import filters
from strings.filters import command
from config import OWNER_ID
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup
from pyrogram.errors import MessageNotModified

url = 'https://us-central1-chat-for-chatgpt.cloudfunctions.net/basicUserRequestBeta'

def gpt(text) -> str:
    headers = {
        'Host': 'us-central1-chat-for-chatgpt.cloudfunctions.net',
        'Connection': 'keep-alive',
        'If-None-Match': 'W/"1c3-Up2QpuBs2+QUjJl/C9nteIBUa00"',
        'Accept': '*/*',
        'User-Agent': 'com.tappz.aichat/1.2.2 iPhone/15.6.1 hw/iPhone8_2',
        'Content-Type': 'application/json',
        'Accept-Language': 'en-GB,en;q=0.9'
    }

    data = {
        'data': {
            'message':text,
        }
    }

    response = requests.post(url, headers=headers, data=json.dumps(data))
    try:
        result = response.json()["result"]["choices"][0]["text"]
        return result
    except:
        return None

def reply_gpt(client, message):
    text = message.text.split("/gpt ")[1]
    reply_text = gpt(text)
    chat_id = message.chat.id
    if message.reply_to_message is not None:
        message_id = message.reply_to_message.message_id
    else:
        message_id = None
    client.send_message(chat_id=chat_id, text=reply_text + "\n\n\n ", reply_to_message_id=message_id)



              
@app.on_message(
    filters.command("cr")
    & ~filters.private
)
async def tom(client: Client, message: Message):
    await message.reply_photo(
        photo=f"https://graph.org/file/c973727bddf803e028539.jpg",
        caption=f"""**â©¹â”â˜…âŠ·â”âŒ ğ˜¾ğ™ â€¢ ğ™ğ™Šğ™ğ™ğ˜¾ğ™€ âŒâ”âŠ¶â˜…â”â©º**\nÙ…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ Ø¹Ø²ÙŠØ²ÙŠ {message.from_user.mention}\n Ø§Ù†Ø§ Ø¨ÙˆØª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ø®Ø§Øµ Ø¨Ø³ÙˆØ±Ø³ cr \nÙ„Ù…Ø¹Ø±ÙØ© Ø§Ù„Ø§ÙˆØ§Ù…Ø± Ø§Ø¶ØºØ· Ø¹Ù„ÙŠ Ø§Ù„Ø§Ø²Ø±Ø§Ø± Ø¨Ø§Ù„Ø§Ø³ÙÙ„ğŸ‘‡\n**â©¹â”â˜…âŠ·â”âŒ ğ˜¾ğ™ â€¢ ğ™ğ™Šğ™ğ™ğ˜¾ğ™€ âŒâ”âŠ¶â˜…â”â©º**""",
        reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        "Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¥Ø³ØªØ®Ø¯Ø§Ù…", callback_data="tommm"), 
                 ],[
                    InlineKeyboardButton(
                        "ğ™ÙÙğ™ŠÙÙğ™ˆÙ", url=f"https://t.me/DEV_TOM"),
                    InlineKeyboardButton(
                        "Ïá¥†ká¥±êª”á¥†êª€", url=f"https://t.me/devpokemon"),
                ],[
                
                    InlineKeyboardButton(
                        "â˜…âŒ ğ˜¾ğ™ â€¢ ğ™ğ™Šğ™ğ™ğ˜¾ğ™€ âŒâš¡", url=f"https://t.me/pp_g3"),
                ],

            ]

        ),

    )



@app.on_callback_query(filters.regex("tommm"))
async def tommm(_, query: CallbackQuery):
    await query.edit_message_text(
        f"""**â©¹â”â˜…âŠ·âŒ¯âŒ ğ˜¾ğ™ â€¢ ğ™ğ™Šğ™ğ™ğ˜¾ğ™€ âŒâŒ¯âŠ¶â˜…â”â©º**
       
â˜…Â¦ Ø§Ù‡Ù„Ø§ Ø¨Ùƒ Ø¹Ø²ÙŠØ²ÙŠ ÙÙŠ Ù‚Ø³Ù… Ø§Ù„Ø£ÙˆØ§Ù…Ø±
â˜…Â¦ Ù„ØªØªÙ…ÙƒÙ† Ù…Ù† ØªØ´ØºÙŠÙ„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙÙ‚Ø· Ø§ÙƒØªØ¨
â˜…Â¦ /gpt - Ù„Ù€Ù„Ù€Ø³Ù€Ø¤Ø§Ù„ Ø¢ÙŠ Ø³Ù€Ø¤Ø§Ù„ Ø¨Ø§Ù„Ù€Ø°ÙƒÙ€Ø§Ø¡ Ø§Ù„Ø§Ø³Ù€Ø·Ù€Ù†Ø§Ø¹ÙŠ

**â©¹â”â˜…âŠ·âŒ¯âŒ ğ˜¾ğ™ â€¢ ğ™ğ™Šğ™ğ™ğ˜¾ğ™€ âŒâŒ¯âŠ¶â˜…â”â©º**""",
        reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        "Ø±Ø¬ÙˆØ¹",
                        switch_inline_query_current_chat="/cr"  
                    ),
                ],
            ]
        ),
    )
